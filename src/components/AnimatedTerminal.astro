---
interface Segment {
  text: string;
  color?: string;
}

interface Line {
  text?: string;
  segments?: Segment[];
  color?: string;
  delay?: number;
}

interface Props {
  id: string;
  title: string;
  command: string;
  lines: Line[];
}

const { id, title, command, lines } = Astro.props;
---

<div class="animated-terminal" data-terminal-id={id}>
  <div class="terminal-header">
    <div class="terminal-buttons">
      <span class="terminal-btn close"></span>
      <span class="terminal-btn minimize"></span>
      <span class="terminal-btn maximize"></span>
    </div>
    <span class="terminal-title">{title}</span>
    <div class="terminal-spacer"></div>
  </div>
  <div class="terminal-body">
    <div class="terminal-prompt">
      <span class="prompt-symbol">$</span>
      <span class="prompt-command" data-command={command}></span>
      <span class="cursor">â–‹</span>
    </div>
    <div class="terminal-output">
      {lines.map((line, i) => (
        <div
          class="output-line"
          data-line-index={i}
          data-delay={line.delay || i * 80}
          style={line.segments ? undefined : `color: ${line.color || '#e5e7eb'}`}
        >
          {line.segments ? (
            line.segments.map((seg) => (
              <span style={`color: ${seg.color || '#e5e7eb'}`}>{seg.text}</span>
            ))
          ) : (
            line.text
          )}
        </div>
      ))}
    </div>
  </div>
</div>

<style is:global>
  .animated-terminal {
    background: #1a1a1a;
    border-radius: 12px;
    overflow: hidden;
    box-shadow: 0 25px 80px rgba(0, 0, 0, 0.6);
    width: 100%;
    max-width: 800px;
    margin: 0 auto;
  }

  .terminal-header {
    background: linear-gradient(180deg, #3d3d3d 0%, #2d2d2d 100%);
    padding: 12px 16px;
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .terminal-buttons {
    display: flex;
    gap: 8px;
  }

  .terminal-btn {
    width: 14px;
    height: 14px;
    border-radius: 50%;
  }

  .terminal-btn.close { background: #ff5f56; }
  .terminal-btn.minimize { background: #ffbd2e; }
  .terminal-btn.maximize { background: #27ca40; }

  .terminal-title {
    flex: 1;
    text-align: center;
    color: #9ca3af;
    font-size: 0.85rem;
    font-family: system-ui, -apple-system, sans-serif;
  }

  .terminal-spacer {
    width: 62px;
  }

  .terminal-body {
    padding: 16px 20px 20px;
    font-family: 'JetBrains Mono', 'SF Mono', 'Monaco', 'Consolas', monospace;
    font-size: 14px;
    line-height: 1.25;
    height: 450px;
    overflow-y: hidden;
    overflow-x: auto;
    /* Hide scrollbar but keep functionality */
    scrollbar-width: none; /* Firefox */
    -ms-overflow-style: none; /* IE/Edge */
  }

  .terminal-body::-webkit-scrollbar {
    display: none; /* Chrome/Safari */
  }

  .terminal-prompt {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-bottom: 8px;
  }

  .prompt-symbol {
    color: #10b981;
    font-weight: bold;
  }

  .prompt-command {
    color: #60a5fa;
  }

  .cursor {
    color: #10b981;
    animation: blink 1s step-end infinite;
  }

  .cursor.hidden {
    display: none;
  }

  @keyframes blink {
    50% { opacity: 0; }
  }

  .terminal-output {
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .terminal-output.visible {
    opacity: 1;
  }

  .output-line {
    opacity: 0;
    transform: translateY(2px);
    transition: opacity 0.15s ease, transform 0.15s ease;
    white-space: pre;
    line-height: 1.25;
    padding: 0;
    margin: 0;
  }

  .output-line.visible {
    opacity: 1;
    transform: translateY(0);
  }

  /* Mobile styles */
  @media (max-width: 768px) {
    .animated-terminal {
      border-radius: 8px;
    }

    .terminal-header {
      padding: 10px 12px;
    }

    .terminal-btn {
      width: 12px;
      height: 12px;
    }

    .terminal-title {
      font-size: 0.75rem;
    }

    .terminal-body {
      padding: 12px 16px 16px;
      font-size: 12px;
      height: 380px;
    }

    .terminal-prompt {
      gap: 8px;
      margin-bottom: 6px;
    }
  }

  @media (max-width: 480px) {
    .terminal-body {
      font-size: 11px;
      height: 340px;
      padding: 10px 12px 14px;
    }
  }
</style>

<script define:vars={{ id, command, linesCount: lines.length }}>
  // Animation logic for this terminal
  document.addEventListener('DOMContentLoaded', () => {
    const terminal = document.querySelector(`[data-terminal-id="${id}"]`);
    if (!terminal) return;

    const commandEl = terminal.querySelector('.prompt-command');
    const cursor = terminal.querySelector('.cursor');
    const output = terminal.querySelector('.terminal-output');
    const outputLines = terminal.querySelectorAll('.output-line');

    let isAnimating = false;
    let animationTimeout;

    async function animateTerminal() {
      if (isAnimating) return;
      isAnimating = true;

      // Reset state
      commandEl.textContent = '';
      cursor.classList.remove('hidden');
      output.classList.remove('visible');
      outputLines.forEach(line => line.classList.remove('visible'));

      // Type command
      for (let i = 0; i <= command.length; i++) {
        await new Promise(r => setTimeout(r, 50 + Math.random() * 30));
        commandEl.textContent = command.slice(0, i);
      }

      // Brief pause after typing
      await new Promise(r => setTimeout(r, 300));

      // Hide cursor, show output
      cursor.classList.add('hidden');
      output.classList.add('visible');

      // Reveal lines progressively
      for (const line of outputLines) {
        const delay = parseInt(line.dataset.delay) || 0;
        await new Promise(r => setTimeout(r, 60));
        line.classList.add('visible');
      }

      // Wait then restart
      await new Promise(r => setTimeout(r, 4000));
      isAnimating = false;
    }

    // Start animation when visible
    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          animateTerminal();
        }
      });
    }, { threshold: 0.5 });

    observer.observe(terminal);
  });
</script>
